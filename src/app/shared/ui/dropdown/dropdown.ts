// Generated by DesignToCode

import { CommonModule, isPlatformBrowser } from '@angular/common';
import {
  AfterViewInit,
  Component,
  computed,
  effect,
  ElementRef,
  forwardRef,
  Inject,
  input,
  OnDestroy,
  output,
  PLATFORM_ID,
  signal,
  viewChild,
} from '@angular/core';
import { FormControl, FormGroup, NG_VALUE_ACCESSOR } from '@angular/forms';
import { SvgIconComponent } from 'angular-svg-icon';
import { Dropdown as FlowbiteDropdown, DropdownInterface, DropdownOptions } from 'flowbite';
import { Subject, takeUntil } from 'rxjs';
import { DropdownInput, DropdownInputIconSrc } from '../dropdown-input/dropdown-input';

export interface DropdownOption {
  id: number;
  label: string;
  value: string;
  icon?: string;
}

@Component({
  selector: 'app-dropdown',
  standalone: true,
  imports: [CommonModule, SvgIconComponent, DropdownInput],
  templateUrl: './dropdown.html',
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => Dropdown),
      multi: true,
    },
  ],
})
export class Dropdown implements AfterViewInit, OnDestroy {
  /** Reference to the dropdown trigger element */
  public dropdownTrigger = viewChild<ElementRef<HTMLElement>>('dropdownTrigger');
  /** Reference to the dropdown target element */
  public dropdownTargetRef = viewChild<ElementRef<HTMLElement>>('dropdownTarget');

  public dropdown: DropdownInterface | undefined;
  public options = input.required<DropdownOption[]>();
  public iconSrc = signal<DropdownInputIconSrc>('chevron-down.svg');
  public formGroup = input.required<FormGroup>();
  public controlName = input<string>('controlName');
  public select = output<DropdownOption>();

  // State
  public selected = signal<DropdownOption | null>(null);
  public filteredOptions = signal<DropdownOption[]>([]);
  public searchTerm = signal<string>('');
  // This is used to differentiate between a simple dropdown and
  // one with searchable options.
  public type = input<'default' | 'search-bar'>('default');

  private destroy$ = new Subject<void>();
  public dropdownExpanded = signal<boolean>(false);

  // ControlValueAccessor properties (for the dropdown's selected value)
  public isDisabled = signal<boolean>(false);
  private onChange = (value: string | null) => {};
  private onTouched = () => {};

  public dropdownForm = new FormGroup({
    dropdownFormControl: new FormControl<unknown>(null),
  });

  private flowbiteOptions: DropdownOptions = {
    placement: 'bottom',
    triggerType: 'click',
    delay: 300,
    onHide: () => {
      this.dropdownExpanded.set(false);
      if (this.dropdownForm.controls.dropdownFormControl && !this.selected()) {
        this.dropdownForm.controls.dropdownFormControl.setValue(null);
        this.dropdownForm.controls.dropdownFormControl.markAsDirty();
        this.dropdownForm.controls.dropdownFormControl.markAsTouched();
      } else if (this.dropdownForm.controls.dropdownFormControl && this.selected()) {
        this.dropdownForm.controls.dropdownFormControl.setValue(this.selected()?.label);
        this.dropdownForm.controls.dropdownFormControl.markAsDirty();
        this.dropdownForm.controls.dropdownFormControl.markAsTouched();
      }
    },
    onShow: () => {
      this.dropdownExpanded.set(true);
    },
    onToggle: () => {
      // Add any custom toggle behavior here
    },
  };

  // Computed signals for classes
  public customClasses = computed(() => {
    const classes: string[] = [];

    this.isDisabled() ? classes.push('cursor-not-allowed') : classes.push('cursor-pointer');

    return classes.join(' ');
  });

  public containerClasses = computed(() => {
    const classes: string[] = [
      'flex',
      'flex-col',
      'flex-nowrap',
      'items-start',
      'justify-start',
      'w-full',
      'h-fit',
      'rounded',
      'gap-2.5',
      'pl-0',
      'pr-0',
      'pt-0',
      'pb-0',
      'relative',
    ];

    return classes.join(' ');
  });

  public dropdownInputClasses = computed(() => {
    const classes: string[] = ['w-full', 'h-[36px]'];

    return classes.join(' ');
  });

  public dropdownTargetClasses = computed(() => {
    const classes: string[] = [
      'flex',
      'bg-[#FCFCFD]',
      'border',
      'border-[#454A54]',
      'rounded',
      'pl-4',
      'pr-4',
      'pt-4',
      'pb-4',
      'w-full',
      'h-fit',
      'max-h-[174px]',
      'hidden',
    ];

    return classes.join(' ');
  });

  public dropdownListClasses = computed(() => {
    const classes: string[] = [
      'flex',
      'flex-col',
      'flex-nowrap',
      'items-start',
      'justify-center',
      'w-full',
      'h-fit',
      'gap-3',
    ];

    return classes.join(' ');
  });

  public dropdownItemClasses = computed(() => {
    const classes: string[] = [
      'flex',
      'flex-row',
      'flex-nowrap',
      'items-center',
      'justify-start',
      'w-full',
      'h-fit',
      'gap-2',
      'pl-0',
      'pr-0',
      'pt-0',
      'pb-0',
    ];

    if (this.isDisabled()) {
      classes.push('cursor-not-allowed');
    } else {
      classes.push('cursor-pointer', 'hover:opacity-80');
    }

    return classes.join(' ');
  });

  public iconClasses = computed(() => {
    const classes: string[] = ['w-[14px]', 'h-[13px]', 'fill-[#454A54]', 'text-[#454A54]'];

    return classes.join(' ');
  });

  public itemContentClasses = computed(() => {
    const classes: string[] = [
      'flex',
      'flex-row',
      'flex-nowrap',
      'items-start',
      'justify-start',
      'w-full',
      'h-fit',
      'pl-0',
      'pr-0',
      'pt-0',
      'pb-0',
    ];

    return classes.join(' ');
  });

  public itemLabelClasses = computed(() => {
    const classes: string[] = [
      'flex',
      'flex-wrap',
      'flex-row',
      'items-start',
      'justify-start',
      'w-full',
      'h-fit',
      'pl-0',
      'pr-0',
      'pt-0',
      'pb-0',
      'text-[#454A54]',
      'fill-[#454A54]',
      'text-sm',
      'font-normal',
      'leading-[21px]',
      'tracking-normal',
      'text-left',
    ];

    return classes.join(' ');
  });

  constructor(@Inject(PLATFORM_ID) private platformId: Object) {
    effect(() => {
      const control = this.getSearchControl();
      if (this.isDisabled()) {
        control?.disable();
      } else {
        control?.enable();
      }
    });

    // Handle dropdown destruction separately
    effect(() => {
      if (this.isDisabled() && this.dropdown) {
        this.dropdown.destroy();
        this.dropdown = undefined;
      }
    });
  }

  ngAfterViewInit() {
    this.initializeDropdown();

    // Initialize filtered options based on current options
    this.updateFilteredOptions();

    // Subscribe to search control changes if provided
    if (this.type() === 'search-bar') {
      this.setupSearchControlSubscription();
    }
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private initializeDropdown(): void {
    if (
      isPlatformBrowser(this.platformId) &&
      this.dropdownTargetRef() &&
      this.dropdownTrigger() &&
      !this.isDisabled()
    ) {
      this.dropdown = new FlowbiteDropdown(
        this.dropdownTargetRef()?.nativeElement,
        this.dropdownTrigger()?.nativeElement,
        this.flowbiteOptions,
      );
      this.dropdown?.hide();
    }
  }

  private updateFilteredOptions(): void {
    const term = this.searchTerm().toLowerCase();

    if (!term) {
      this.filteredOptions.set(this.options());
    } else {
      this.filteredOptions.set(
        this.options().filter((option) => option.label.toLowerCase().includes(term)),
      );
    }
  }

  private setupSearchControlSubscription(): void {
    const control = this.getSearchControl();
    if (control) {
      control.valueChanges.pipe(takeUntil(this.destroy$)).subscribe((searchValue) => {
        this.filterOptions((searchValue as string) || '');
      });
    }
  }

  writeValue(value: string | null): void {
    if (value !== null && value !== undefined) {
      this.initializeSelectedOption(value);
    } else {
      this.selected.set(null);
    }
  }

  registerOnChange(fn: (value: string | null) => void): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }

  setDisabledState(isDisabled: boolean): void {
    this.isDisabled.set(isDisabled);
  }

  private initializeSelectedOption(value: string) {
    // Check in options to find the matching option
    const found = this.options().find((o) => o.value === value);

    if (found) {
      this.selected.set(found);
      const control = this.getSearchControl();
      if (control) {
        control.setValue(found.label, { emitEvent: false });
      }
    }
  }

  private filterOptions(term: string): void {
    this.searchTerm.set(term);
    this.updateFilteredOptions();
  }

  public onSelect(option: DropdownOption): void {
    if (this.isDisabled()) return;

    this.selected.set(option);

    const control = this.getSearchControl();
    if (control) {
      control.setValue(option.label, { emitEvent: false }); // Don't trigger filtering
    }

    // Notify the form control of the change
    this.onChange(option.value);
    this.onTouched();

    this.dropdown?.hide();
    this.select.emit(option);
  }

  /**
   * Hides the dropdown menu and returns focus to the trigger
   */
  public hideDropdownMenu(): void {
    this.dropdownTrigger()?.nativeElement.focus();
    this.dropdown?.hide();
    this.onTouched();
  }

  /**
   * Moves focus to the next dropdown option (with wrapping)
   * @param currentIndex - The current focused option index
   */
  public focusNext(currentIndex: number): void {
    const nextIndex = currentIndex === this.filteredOptions().length - 1 ? 0 : currentIndex + 1;
    (
      this.dropdownTargetRef()?.nativeElement.children[0].children[nextIndex] as HTMLElement
    ).focus();
  }

  /**
   * Moves focus to the previous dropdown option (with wrapping)
   * @param currentIndex - The current focused option index
   */
  public focusPrev(currentIndex: number): void {
    const nextIndex = currentIndex === 0 ? this.filteredOptions().length - 1 : currentIndex - 1;
    (
      this.dropdownTargetRef()?.nativeElement.children[0].children[nextIndex] as HTMLElement
    ).focus();
  }

  /**
   * Gets the search control if available
   */
  private getSearchControl(): FormControl | null {
    const formGroup = this.dropdownForm;
    const controlName = 'dropdownFormControl';
    if (formGroup && controlName) {
      return formGroup.get(controlName) as FormControl;
    }
    return null;
  }
}
