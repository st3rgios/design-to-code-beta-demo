// Generated by DesignToCode

import { CommonModule } from "@angular/common";
import {
  Component,
  ElementRef,
  OnDestroy,
  OnInit,
  ViewChild,
  computed,
  effect,
  input,
  signal
} from "@angular/core";
import {
  FormControl,
  FormGroup,
  FormsModule,
  ReactiveFormsModule,
} from "@angular/forms";
import { SvgIconComponent } from "angular-svg-icon";
import { Subject, takeUntil } from "rxjs";

export type DropdownInputIconSrc = "chevron-down.svg" | "chevron-up.svg";

@Component({
  selector: "app-dropdown-input",
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule, SvgIconComponent],
  templateUrl: "./dropdown-input.html",
})
export class DropdownInput implements OnInit, OnDestroy {
  @ViewChild("inputContainer", { static: true }) inputContainerRef!: ElementRef;

  // Inputs
  // All signals are accessed using `()` in both html and ts
  public formGroup = input.required<FormGroup>();
  public controlName = input.required<string>();
  public label = input<string>("");
  // Makes the input readonly
  public readonly = input<boolean>(false);
  public showValidationTemplates = input<boolean>(false);
  public placeholder = input<string>("");
  public disabled = input<boolean>(false);
  public selectedValue = input<string>("");
  public iconSrc = input<DropdownInputIconSrc>("chevron-down.svg");

  // States
  private isHovered = signal(false);
  private isFilling = signal(false);
  private isFocused = signal(false);
  private isFilled = signal(false);

  private destroy$ = new Subject<void>();

  private formState = signal({
    invalid: false,
    dirty: false,
    touched: false,
    valid: false,
  });

  constructor() {
    effect(() => {
      const fc = this.formGroup()?.get(this.controlName());
      if (fc?.value != null && fc?.value !== "") {
        this.isFilled.set(true);
      }
    });
  }

  ngOnInit(): void {
    if (this.control() != null) {
      this.control()
        .statusChanges.pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          if (
            this.formState().dirty !== this.control().dirty ||
            this.formState().invalid !== this.control().invalid ||
            this.formState().touched !== this.control().touched ||
            this.formState().valid !== this.control().valid
          ) {
            this.formState.set({
              invalid: this.control().invalid,
              dirty: this.control().dirty,
              touched: this.control().touched,
              valid: this.control().valid,
            });
          }
        });

      this.control()
        .valueChanges.pipe(takeUntil(this.destroy$))
        .subscribe((value) => {
          this.isFocused.set(false);
          this.isFilling.set(true);
        });
    }
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  public control = computed(() => {
    const fc = this.formGroup()?.get(this.controlName());
    return fc as FormControl;
  });

  public onMouseEnter() {
    this.isHovered.set(true);
  }

  public onMouseLeave() {
    this.isHovered.set(false);
  }

  public onFocus() {
    this.isFocused.set(true);
    this.isFilled.set(false);
  }

  public onBlur() {
    this.isFocused.set(false);
    this.isFilling.set(false);
    this.isFilled.set(
      this.control().value != null && this.control().value !== "",
    );
    this.formState.set({
      invalid: this.control().invalid,
      dirty: this.control().dirty,
      touched: this.control().touched,
      valid: this.control().valid,
    });
  }

  public tabIndexInput = computed(() => {
    return this.disabled() || this.readonly() ? -1 : 0;
  });

  public containerClasses = computed(() => {
    // Constructing classes
    const classes: string[] = [
      "flex",
      "flex-nowrap",
      "items-center",
      "justify-start",
      "w-full",
      "h-fit",
      "gap-4",
      "bg-[#FCFCFD]",
      "pl-2",
      "pr-2",
      "pt-2",
      "pb-2",
      "rounded",
      "border",
      "cursor-pointer",
    ];

    // State-based classes (color, background, shadow, border-color etc...)
    if (this.hasError()) {
      classes.push("border-[#454A54]");
    } else if (this.isSuccess()) {
      classes.push("border-[#454A54]");
    } else {
      if (this.isFilling() && !this.disabled() && !this.readonly()) {
        classes.push(
          "border-[#0096CD]",
          "shadow-[0px_0px_0px_2px_rgba(0,150,205,0.1)]",
        );
      } else if (this.isFocused() && !this.disabled() && !this.readonly()) {
        classes.push(
          "border-[#0096CD]",
          "shadow-[0px_0px_0px_2px_rgba(0,150,205,0.1)]",
        );
      } else if (this.isHovered() && !this.disabled() && !this.readonly()) {
        classes.push("border-[#015364]", "hover:border-[#015364]");
      } else if (this.isFilled() && !this.disabled() && !this.readonly()) {
        classes.push("border-[#454A54]");
      } else if (this.disabled() || this.readonly()) {
        classes.push("border-[#DCE4ED]", "cursor-not-allowed");
      } else {
        // default state
        classes.push("border-[#454A54]");
      }
    }

    return classes.join(" ");
  });

  public innerContainerClasses = computed(() => {
    const classes: string[] = [
      "flex",
      "flex-row",
      "flex-nowrap",
      "items-center",
      "justify-start",
      "w-full",
      "h-fit",
      "gap-1",
      "pl-0",
      "pr-0",
      "pt-0",
      "pb-0",
    ];

    return classes.join(" ");
  });

  public textContainerClasses = computed(() => {
    const classes: string[] = [
      "flex",
      "flex-row",
      "flex-nowrap",
      "items-start",
      "justify-start",
      "w-full",
      "h-fit",
      "gap-2.5",
      "pl-0",
      "pr-0",
      "pt-0",
      "pb-0",
    ];

    return classes.join(" ");
  });

  public placeholderClasses = computed(() => {
    const classes: string[] = [
      "text-sm",
      "font-normal",
      "leading-5",
      "tracking-normal",
      "text-left",
      "w-full",
      "h-fit",
    ];

    if (this.disabled() || this.readonly()) {
      classes.push("text-[#838B98]");
    } else {
      classes.push("text-[#454A54]");
    }

    return classes.join(" ");
  });

  public selectedValueClasses = computed(() => {
    const classes: string[] = [
      "text-sm",
      "font-normal",
      "leading-5",
      "tracking-normal",
      "text-left",
      "w-full",
      "h-fit",
    ];

    if (this.hasError()) {
      classes.push("text-[#454A54]");
    } else if (this.isSuccess()) {
      classes.push("text-[#454A54]");
    } else {
      if (this.disabled() || this.readonly()) {
        classes.push("text-[#838B98]");
      } else {
        classes.push("text-[#454A54]");
      }
    }

    return classes.join(" ");
  });

  public iconContainerClasses = computed(() => {
    const classes: string[] = [
      "flex",
      "flex-col",
      "flex-nowrap",
      "items-center",
      "justify-center",
      "w-[16px]",
      "h-fit",
      "gap-2.5",
      "pl-1",
      "pr-1",
      "pt-1.5",
      "pb-1.5",
    ];

    return classes.join(" ");
  });

  public iconClasses = computed(() => {
    const classes: string[] = ["w-[8px]", "h-[5px]"];

    if (this.hasError()) {
      classes.push("fill-[#454A54]");
    } else if (this.isSuccess()) {
      classes.push("fill-[#454A54]");
    } else {
      if (this.disabled() || this.readonly()) {
        classes.push("fill-[#838B98]");
      } else if (this.isHovered() && !this.disabled() && !this.readonly()) {
        classes.push("fill-[#454A54]");
      } else {
        classes.push("fill-[#454A54]");
      }
    }

    return classes.join(" ");
  });

  // Check if field has error
  public hasError = computed(() => {
    const state = this.formState();
    return (
      (state.invalid &&
        state.dirty &&
        state.touched &&
        this.showValidationTemplates() &&
        !this.isFilling()) ||
      false
    );
  });

  public isSuccess = computed(() => {
    const state = this.formState();
    return (
      (state.valid &&
        state.dirty &&
        this.showValidationTemplates() &&
        !this.isFilling()) ||
      false
    );
  });

  public messageClasses = computed(() => {
    // Constructing classes
    const classes: string[] = [];

    return classes.join(" ");
  });
}
